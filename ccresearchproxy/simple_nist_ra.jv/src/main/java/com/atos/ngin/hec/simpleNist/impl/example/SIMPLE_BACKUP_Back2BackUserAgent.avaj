package com.atos.ngin.hec.simpleNist.impl.example;

import gov.nist.javax.sip.DialogTimeoutEvent;
import gov.nist.javax.sip.ListeningPointExt;
import gov.nist.javax.sip.SipListenerExt;
import gov.nist.javax.sip.SipProviderExt;
import gov.nist.javax.sip.SipStackImpl;

import java.io.FileInputStream;
import java.io.IOException;
import java.text.ParseException;
import java.util.HashSet;
import java.util.Hashtable;
import java.util.Properties;
import java.util.Random;
import java.util.concurrent.atomic.AtomicLong;

import javax.management.NotCompliantMBeanException;
import javax.management.StandardMBean;
import javax.sip.ClientTransaction;
import javax.sip.Dialog;
import javax.sip.DialogTerminatedEvent;
import javax.sip.IOExceptionEvent;
import javax.sip.InvalidArgumentException;
import javax.sip.ListeningPoint;
import javax.sip.RequestEvent;
import javax.sip.ResponseEvent;
import javax.sip.ServerTransaction;
import javax.sip.SipException;
import javax.sip.SipFactory;
import javax.sip.SipProvider;
import javax.sip.SipStack;
import javax.sip.TimeoutEvent;
import javax.sip.TransactionAlreadyExistsException;
import javax.sip.TransactionTerminatedEvent;
import javax.sip.TransactionUnavailableException;
import javax.sip.address.AddressFactory;
import javax.sip.address.SipURI;
import javax.sip.header.CSeqHeader;
import javax.sip.header.ContactHeader;
import javax.sip.header.FromHeader;
import javax.sip.header.HeaderFactory;
import javax.sip.header.RouteHeader;
import javax.sip.header.ViaHeader;
import javax.sip.message.MessageFactory;
import javax.sip.message.Request;
import javax.sip.message.Response;

import org.apache.log4j.Logger;

import com.atos.ngin.hec.simpleNist.impl.SimpleNISTResourceAdaptor;
import com.atos.ngin.hec.simpleNist.impl.SimpleNistProcessor;
import com.atos.ngin.hec.simpleNist.impl.callmng.CallProcessor;
import com.atos.ngin.hec.simpleNist.impl.callmng.CallProcessorMBean;
import com.atos.ngin.hec.simpleNist.impl.callmng.CallProcessorStats.MessageStats;

//import test.tck.msgflow.callflows.ProtocolObjects;


public abstract class SIMPLE_BACKUP_Back2BackUserAgent extends StandardMBean implements SipListenerExt, SimpleNistProcessor, CallProcessorMBean {
    
	//    private HashSet<Dialog> dialogs = new HashSet<Dialog>();
    private ListeningPoint[] listeningPoints = new ListeningPoint[2]; 
    private SipProvider[] providers = new SipProvider[2];
    private MessageFactory messageFactory;
    private Hashtable<Dialog,Response> lastResponseTable = new Hashtable<Dialog,Response>();
//    private ProtocolObjects protocolObjects;
    private HeaderFactory headerFactory;
    private AddressFactory addressFactory;
	//    
	//    public Dialog getPeer(Dialog dialog) {
	//        Object[] dialogArray = dialogs.toArray();
	//        if ( dialogArray.length < 2) return null;
	//        if ( dialogArray[0] == dialog) return (Dialog) dialogArray[1];
	//        else if ( dialogArray[1] == dialog) return (Dialog) dialogArray[0];
	//        else return null;
	//    }
    
    public SipProvider getPeerProvider (SipProvider provider) {
        if ( providers[0] == provider) return providers[1];
        else return providers[0];
    }
    
	//    public void addDialog(Dialog dialog) {
	//        this.dialogs.add(dialog);
	//        if (logger.isInfoEnabled())logger.info("Dialogs  " + this.dialogs);
	//    }
    
    public void forwardRequest(RequestEvent requestEvent, 
            ServerTransaction serverTransaction) throws SipException, ParseException, InvalidArgumentException  {
    	
    	Request newRequest = null;
    	try
    	{
	        SipProvider provider = (SipProvider) requestEvent.getSource();
	        Dialog dialog = serverTransaction.getDialog();
	        Object appData = dialog.getApplicationData();
	        Dialog peerDialog = appData != null? (Dialog)appData:null;
	        
	        //Dialog peerDialog = this.getPeer(dialog);
	        Request request = requestEvent.getRequest(); 
	        
	        if (logger.isInfoEnabled())logger.info("Request: Dialog " + dialog);
	        if (logger.isInfoEnabled())logger.info("Request: Peer Dialog " + peerDialog);
	        
	        
	        if ( peerDialog != null ) {
	             newRequest = peerDialog.createRequest(request.getMethod());
	        } else {
	             newRequest = (Request) request.clone();
	             ((SipURI)newRequest.getRequestURI()).setPort(5090);
	             newRequest.removeHeader(RouteHeader.NAME);
	             FromHeader fromHeader = (FromHeader) newRequest.getHeader(FromHeader.NAME);
	             fromHeader.setTag(Long.toString(Math.abs(new Random().nextLong())));
	             SipProvider peerProvider = getPeerProvider(provider);
	             ViaHeader viaHeader = ((ListeningPointExt) ((SipProviderExt)
	                     getPeerProvider(provider)).getListeningPoint(stackTransport)).createViaHeader();
	             newRequest.setHeader(viaHeader);
	             
	        }
	        ContactHeader contactHeader = ((ListeningPointExt) ((SipProviderExt)
	                                    getPeerProvider(provider)).getListeningPoint(stackTransport)).createContactHeader();
	        newRequest.setHeader(contactHeader);
	        ClientTransaction clientTransaction = provider.getNewClientTransaction(newRequest);
	        clientTransaction.setApplicationData(serverTransaction);
	        if (request.getMethod().equals(Request.INVITE)) {
	        	Dialog newDialog = clientTransaction.getDialog();
	        	//	            this.addDialog(clientTransaction.getDialog());
	            dialog.setApplicationData(newDialog);
	            newDialog.setApplicationData(dialog);
	        }
	        if ( peerDialog != null ) {
	            peerDialog.sendRequest(clientTransaction);
	        } else {
	            clientTransaction.sendRequest();
	        }
	        if (logger.isInfoEnabled())logger.info("Request forwarded");
    	}
    	catch(Exception e)
    	{
    		logger.error("Could not forward Request: "+newRequest);
    		e.printStackTrace();
    	}
        
    }

   
    public void processDialogTimeout(DialogTimeoutEvent timeoutEvent) {
      
    }

    public void processDialogTerminated(DialogTerminatedEvent dialogTerminatedEvent) {
        
    }
 
     public void processIOException(IOExceptionEvent exceptionEvent) {
        // TODO Auto-generated method stub
        
    }

    public void processRequest(RequestEvent requestEvent) {
        try {
            Request request = requestEvent.getRequest();
            if (logger.isInfoEnabled())logger.info("Request: "+request.getMethod());
            SipProvider provider = (SipProvider) requestEvent.getSource();
            if (request.getMethod().equals(Request.INVITE)) {
                if (requestEvent.getServerTransaction() == null) {
                    try {
                        ServerTransaction serverTx = provider.getNewServerTransaction(request);
                        //                        this.addDialog(serverTx.getDialog());
                        this.forwardRequest(requestEvent,serverTx);
                    } catch (TransactionAlreadyExistsException ex) {
                    	logger.error("Transaction exists -- ignoring");
                    } catch (Exception ex) {
                        ex.printStackTrace();
//                        BackToBackUserAgentTest.fail("Unepxected exception");
                    }
                } else {
                    this.forwardRequest(requestEvent,requestEvent.getServerTransaction());
                }
            } else if ( request.getMethod().equals(Request.BYE)) {
                ServerTransaction serverTransaction = requestEvent.getServerTransaction();
                if ( serverTransaction == null ) {
                    serverTransaction = provider.getNewServerTransaction(request);
                }
                this.forwardRequest(requestEvent, serverTransaction);
               
            } else if (request.getMethod().equals(Request.ACK)) {
                Dialog dialog = requestEvent.getDialog();
    	        Object appData = dialog.getApplicationData();
    	        Dialog peer = appData != null? (Dialog)appData:null;                
    	        //                Dialog peer = this.getPeer(dialog);
    	        if(peer != null)
    	        {
	                Response response = this.lastResponseTable.get(peer);
	                CSeqHeader cseqHeader = (CSeqHeader) response.getHeader(CSeqHeader.NAME);
	                String method = cseqHeader.getMethod();
	                long seqno = cseqHeader.getSeqNumber();
	                Request ack = peer.createAck(seqno);
	                peer.sendAck(ack);
	                if (logger.isInfoEnabled())logger.info("ACK sent");
    	        }
    	        else
    	        {
    	        	logger.error("Cannot find peer for Dialog: "+dialog);
    	        }
            }
           
        } catch ( Exception ex) {
            ex.printStackTrace();
        }
    }


    private void cleanUp(Dialog dialog)
    {
    	//    	if(logger.isInfoEnabled())logger.info("Should we clean?: "+getStackState());
    	if (dialog != null)
    	{    		
    		Dialog peerDialog = (Dialog)dialog.getApplicationData();
    		dialog.setApplicationData(null);
    		if (peerDialog != null)
    		{    			
    			peerDialog.setApplicationData(null);
    			this.lastResponseTable.remove(peerDialog);
    		}
    		this.lastResponseTable.remove(dialog);    		
    	}
    	
    }
    public void processResponse(ResponseEvent responseEvent) {
        try {
            Response response = responseEvent.getResponse();
            Dialog dialog = responseEvent.getDialog();
            if (logger.isInfoEnabled())logger.info("Response: " + response.getStatusCode());
            if (logger.isInfoEnabled())logger.info("Response: " + response.getReasonPhrase());
            this.lastResponseTable.put(dialog, response);
             ServerTransaction serverTransaction = (ServerTransaction)responseEvent.getClientTransaction().getApplicationData();
            Request stRequest = serverTransaction.getRequest();
	        if (logger.isInfoEnabled())logger.info("Response: Dialog " + dialog.getDialogId());
	        if (logger.isInfoEnabled())logger.info("Response: Server Transaction " + serverTransaction);            
            Response newResponse = this.messageFactory.createResponse(response.getStatusCode(),stRequest);
            SipProvider provider = (SipProvider)responseEvent.getSource();
            SipProvider peerProvider = this.getPeerProvider(provider);
            ListeningPoint peerListeningPoint = peerProvider.getListeningPoint(stackTransport);
            ContactHeader peerContactHeader = ((ListeningPointExt)peerListeningPoint).createContactHeader();
            newResponse.setHeader(peerContactHeader);
            serverTransaction.sendResponse(newResponse);
            if(response.getStatusCode() / 100 > 1)
            {
            	responseEvent.getClientTransaction().setApplicationData(null);
            }
            if (logger.isInfoEnabled())logger.info("Response sent for request method "+stRequest.getMethod());
            if( stRequest.getMethod().equals("BYE"))
            {
            	cleanUp(dialog);
            }
            	
            
        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }

    public void processTimeout(TimeoutEvent timeoutEvent) {
        // TODO Auto-generated method stub
        
    }

    public void processTransactionTerminated(TransactionTerminatedEvent transactionTerminatedEvent) {
         
    }
    
	private Logger logger = null;    
	SipStack sipStack = null;
	ListeningPoint lp1=null, lp2=null;
	SipProvider sp1=null, sp2=null;
	String stackAddress = "127.0.0.1";
	int stackPortIngress = 6060;
	int stackPortEgress = 6070;
	String stackTransport = "udp";
	
    public SipStack init (String configFilePath, SimpleNISTResourceAdaptor ra) {
    	logger = Logger.getLogger(ra.getRaContext().getEntityName()+".Back2BackUserAgent");
    	SipFactory sipFactory = null;      
    	
        sipFactory = SipFactory.getInstance();
        sipFactory.setPathName("gov.nist");
        Properties properties = new Properties();
//        this.protocolObjects = new ProtocolObjects("backtobackua","gov.nist","udp",true,true, false);		
        //try retrieve data from file
		try 
		{	
			if (logger.isInfoEnabled())logger.info("Loading stack properties file: "+configFilePath);
			properties.load(new FileInputStream(configFilePath));
		            
		}
		catch(IOException e)
		{
			e.printStackTrace();
		}     
        try {
        	if (logger.isInfoEnabled())logger.info("Stack properties: "+properties.toString());
        	
			stackAddress = properties.getProperty("com.atos.cc.IP_ADDRESS");
			stackTransport = properties.getProperty("com.atos.cc.STACK_TRANSPORT");
			stackPortIngress = Integer.parseInt(properties.getProperty("com.atos.cc.STACK_PORT"));
			stackPortEgress = stackPortIngress+10;
			
			headerFactory = sipFactory.createHeaderFactory();
			addressFactory = sipFactory.createAddressFactory();
			messageFactory = sipFactory.createMessageFactory();
			sipStack = sipFactory.createSipStack(properties);
            lp1 = sipStack.createListeningPoint(stackAddress, stackPortIngress, stackTransport);
            lp2 = sipStack.createListeningPoint(stackAddress, stackPortEgress, stackTransport);
            sp1 = sipStack.createSipProvider(lp1);
            sp2 = sipStack.createSipProvider(lp2);
            this.listeningPoints[0] = lp1;
            this.listeningPoints[1] = lp2;
            this.providers[0] = sp1;
            this.providers[1] = sp2;
            sp1.addSipListener(this);
            sp2.addSipListener(this);

        } catch (Exception ex) {
            ex.printStackTrace();
        }
        return sipStack;
    }
	/**
	 * Shutdown
	 */
	public void shutdown() throws Exception
	{
		sipStack.stop();
		sp1.removeSipListener(this);
		sp2.removeSipListener(this);
		sp1.removeListeningPoint(lp1);
		sp2.removeListeningPoint(lp2);
		sipStack.deleteListeningPoint(lp1);
		sipStack.deleteListeningPoint(lp2);
		sipStack.deleteSipProvider(sp1);
		sipStack.deleteSipProvider(sp2);
		
		sp1 = null;
		sp2 = null;
		lp1 = null;
		lp2 = null;
		messageFactory = null;
		headerFactory = null;
		addressFactory = null;
		
		sipStack = null;
	}

	public SIMPLE_BACKUP_Back2BackUserAgent()throws NotCompliantMBeanException
	{
		super(CallProcessorMBean.class);
	}	
	private int getStackPendingTransactionTableSize()
	{
		//This is a bit tricky: we'll use the CongestionControlMessageValve instead in the future
		return ((SipStackImpl)sipStack).getPendingTransactionsSize();
	}
	private int getStackTransactionTableSize()
	{
		//This is a bit tricky: we'll use the CongestionControlMessageValve instead in the future
		return ((SipStackImpl)sipStack).getServerTransactionTableSize();
	}
	private int getStackDialogTableSize()
	{
		//This is a bit tricky: we'll use the CongestionControlMessageValve instead in the future
		return ((SipStackImpl)sipStack).getDialogsSize();
	}
	public String getStackState()
	{
		StringBuilder sb = new StringBuilder(50);
		sb.append(" Dialogs / Transactions / PendingTransactions : ")
			.append(getStackDialogTableSize()).append(" / ")
			.append(getStackTransactionTableSize()).append(" / ")
			.append(getStackPendingTransactionTableSize());
		return sb.toString();
	}
	
	public String getQueuesState()
	{		
		return getStackState();
	}

	public String dumpCounters()
	{
		// TODO Auto-generated method stub
		return "NO counters";
	}

	public String resetCounters()
	{
		// TODO Auto-generated method stub
		return "NO counters";
	}
	public int getCDRQueueOccupancy()
	{
		return -1;
	}
	static AtomicLong sn = new AtomicLong(0);
	public long incrementAndGetSerialNumber()
	{
		return sn.incrementAndGet();
	}
	public long getSerialNumber()
	{
		return sn.longValue();
	}	
}
